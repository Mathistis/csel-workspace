![MSE Logo](../../logo.png)
# Rapport de laboratoire 

## 1 Résumé du laboratoire
Dans ce TP, nous allons mettre en place un environnement de développement afin de faciliter les développements futures. Cet environnement utilise des container Docker (Docker-compose) pour assurer la compatibilité entre les différentes machines. Un container est composé de tous les outils nécessaire à la cross-compilation et l'autre pour la mise en place d'une partition réseau SAMBA afin de partager facilement les programmes cross-compilés avec le NanoPi.
## 2 Réponse aux questions

> - **Comment faut-il procéder pour générer l’U-Boot ?** \
On peut regénérer le u-boot uniquement avec la commande : make uboot-rebuild\
See : https://github.com/ARM-software/u-boot/blob/master/Makefile \
--> TODO : Ajouter 5-6 lignes qui expliquent ce que fais le make de U-Boot
 
> - **Comment peut-on ajouter et générer un package supplémentaire dans le Buildroot ?** \
Je ne comprends pas trop le sens de la question mais au sens général, il faut ajouter le binaire ainsi que des fichiers de configurations (qui définissent par exemple les dépendances). On peut par exemple importer depuis GitLab automatiquement un packet, ou encore ajouter des paquet pour le user space ou le kernel space et tout cela change les étapes a effectuer. Pour plus d'informations, la section 18 de la [documentation](https://buildroot.org/downloads/manual/manual.html#adding-packages).

> - **Comment doit-on procéder pour modifier la configuration du noyau Linux ?** \
La commande make linux-menuconfig permet de configurer le noyau et on peut ensuite ajouter/enlever des modules du noyaux et finalement faire make linux-rebuild afin de reconstruire le noyau.

> - **Comment faut-il faire pour générer son propre rootfs ?** \
Comme c'est Buildroot qui s'occupe de générer le Rootfs, c'est lui qu'il faut configurer \
cd /buildroot \
make menuconfig \
On peut aussi par exemple modifier le skelette utilisé pour modifier la structure des dossiers du rootfs. On peut aussi ajouter des fichiers/scripts/dossiers par défaut dans le rootfs en ajoutant un rootfs_overlay */buildroot/board/friendlyarm/nanopi-neo-plus2/rootfs_overlay/*. Ils seront automatiquement inséré dans le rootfs après chaques générations.

> - **Comment faudrait-il procéder pour utiliser la carte eMMC en lieu et place de la carte SD ?** \
Il faut commencer par modifier le script de démarrage en modifiant les deux lignes suivantes. Il faut remplacer le **0** par le numéro de MMC que l'on veut : \
fatload mmc **0** $kernel_addr_r Image \
fatload mmc **0** $fdt_addr_r nanopi-neo-plus2.dtb \
On peut avoir des informations sur les mmc disponible en interrompant le U-Boot et en tappant la commande : \
=> mmc list \
mmc@1c0f000: 0 (SD) \
mmc@1c10000: 2 \
mmc@1c11000: 1 \
Il faut ensuite recompiler le script avec la commande make et reflasher la carte. Enfin il de faut pas oublier également de charger l'Image et le device tree depuis la carte SD vers la mmc interne (a faire une seul fois) ainsi que de modifier le scipt de démarrage pour utiliser celui que l'on vient de compiler avec la commande : \
setenv boot_scripts boot.cifs \
Finalement, on peut sauvegarder les modifications avec la commande : \
saveenv

> - **Dans le support de cours, on trouve différentes configurations de l’environnement de développement. Qu’elle serait la configuration optimale pour le développement uniquement d’applications en espace utilisateur ?** \
Si on développe uniquement dans le userspace, on pourrait imaginer que l'on flash la eMMC comme décrit à la question précédente pour s'affranchir de carte SD et qu'on développe sur notre ordinateur. Pour le partage des programmes une partition NFS ou la partition CIFS sont très bien et permettent de rendre transparent le transfert des programmes.

## 3 Synthèse des connaissances acquises
- **Non acquis** 
  - Aucune
- **Acquis, mais à exercer**
  - Les Makefile
- **Parfaitement acquis**
  - Tout le reste (déjà globalement vu dans le cours de Système embarqué 4).

## 4 Choses à retenir
Pour monter automatiquement un disque réseau cifs : \
> echo "//\<server_ip>/workspace /workspace cifs username=\<username>,password=\<password>,port=1445,noserverino" >> /etc/fstab \

Lorsqu'on créer une nouvelle partition, il faut l'aligner sur 2048 bits. On peut calculer le début de la prochaine partition par rapport à la précédente comme ceci : 
> \<prev_end_sector> + (2048 - \<prev_end_sector>  % 2048)


## 5 Feedback personnel sur le laboratoire
Dans l'ensemble laboratoire très intéressant. Assez dirigé pour nous indiquer la bonne voie mais pas trop pour qu'on puisse tester des choses. J'aurais bien aimé un peu plus de maitère sur les Makefiles.

# TP02
## Questions
> - **Trouvez la signification des 4 valeurs affichées lorsque l’on tape la commande cat /proc/sys/kernel/printk**\
Cela affiche les console_loglevel (niveaux de logs de la console) actuels, dans notre cas sur le nanopi les valeurs affichées sont 7 4 1 7, comme le montre la [documentation](https://www.kernel.org/doc/html/latest/core-api/printk-basics.html) l'ordre des chiffres correspond à :
  1.  current
  2.  default
  3.  minimum
  4.  boot-time-default

![Console log levels](images/console_loglevels.png)
Raemy Mathis, Macherel Rémy